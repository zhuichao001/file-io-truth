## Page Cache(内核读写缓存)
在磁盘进行标准IO操作时，操作系统内核会先把数据写入到PageCache，读取数据时会直接从Cache中读取，同时减少了IO的次数，达到了提升读写效率。

#### 文件读流程
1. 应用程序发起读请求，由系统调用`read()`函数，用户态切换为内核态
2. 文件系统通过目录项、页缓存树(Radix tree)，查询Page Cache，如果存在则直接读取(避免了对物理磁盘I/O操作)
3. Page Cache不存在产生缺页中断，CPU向DMA发出控制指令, DMA 控制器将数据从硬盘拷贝到内核空间的缓冲区（read buffer）
4. DMA 磁盘控制器向 CPU 发出数据读完的信号，由 CPU 负责将数据从内核缓冲区拷贝到用户缓冲区
5. 用户进程由内核态切换回用户态，获得文件数据

#### 文件写流程
1. 应用程序发起写请求，由系统调用`write()`函数，用户态切换为内核态
2. 文件系统通过目录项、页缓存树，查询 Page Cache是否存在，如果不存在则需要创建
3. Page Cache 存在后，CPU将数据从用户缓冲区拷贝到内核缓冲区，Page Cache 变为脏页，写流程返回
4. 用户主动触发刷盘或者达到特定条件后内核触发刷盘，唤醒 pdflush 线程，pdflush 将内核缓冲区的数据刷入磁盘

#### Linux内核实现页缓存机制
```
struct file {
    ...
    struct address_space *f_mapping;
};

struct address_space {
    struct inode           *host;      /* owner: inode, block_device */
    struct radix_tree_root page_tree;  /* radix tree of all pages */
    rwlock_t               tree_lock;  /* and rwlock protecting it */
    ...
};

```
__读文件调用链:__  
> read()
>> sys_read()
>>> vfs_read()
>>>> do_sync_read()
>>>>> generic_file_aio_read()
>>>>>> do_generic_file_read()
>>>>>>> do_generic_mapping_read()
```
void
do_generic_mapping_read(struct address_space *mapping,
        struct file_ra_state *_ra,
        struct file *filp,
        loff_t *ppos,
        read_descriptor_t *desc,
        read_actor_t actor) 
{
    struct inode *inode = mapping->host;
    unsigned long index;
    struct page *cached_page;
    ...
    cached_page = NULL;
    index = *ppos >> PAGE_CACHE_SHIFT;
    ...
    for (;;) {
        struct page *page;
        ...
        find_page:
        // 1. 查找文件偏移量所在的页缓存是否存在
        page = find_get_page(mapping, index);
        if (!page) {
            ...
            // 2. 如果页缓存不存在, 那么跳到 no_cached_page 进行处理
            goto no_cached_page; 
        }
        ...
        page_ok:
        ...
        // 3. 如果页缓存存在, 那么把页缓存的数据拷贝到用户应用程序的内存中
        ret = actor(desc, page, offset, nr);
        ...
        if (ret == nr && desc->count)
            continue;
        goto out;
        ...
        readpage:
        // 4. 从文件读取数据到页缓存中
        error = mapping->a_ops->readpage(filp, page);
        ...
        goto page_ok;
        ...
        no_cached_page:
        if (!cached_page) {
            // 5. 申请一个内存页作为页缓存
            cached_page = page_cache_alloc_cold(mapping);
            ...
        }
        // 6. 把新申请的页缓存添加到文件页缓存中
        error = add_to_page_cache_lru(cached_page, mapping, index, GFP_KERNEL);
        ...
        page = cached_page;
        cached_page = NULL;
        goto readpage;
    }
out:
    ...
}
```

```
int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
                            pgoff_t offset, gfp_t gfp_mask)
{
    // 1. 把页缓存添加到文件页缓存中
    int ret = add_to_page_cache(page, mapping, offset, gfp_mask);
    if (ret == 0) 
        // 2. 把页缓存添加到 LRU 队列中
        lru_cache_add(page); 
   return ret;
}
```
