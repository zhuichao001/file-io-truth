## 直接与非直接 I/O
磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。

那么，根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：
- 直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。
- 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

如果调用open()函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O; 否则默认是非直接 I/O。

如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？
- 在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； 
- 用户主动调用 sync，内核缓存会刷到磁盘上； 
- 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； 
- 内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；
